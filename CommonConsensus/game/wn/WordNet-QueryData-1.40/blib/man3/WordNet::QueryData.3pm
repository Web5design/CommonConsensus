.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "QueryData 3pm"
.TH QueryData 3pm "2005-12-30" "perl v5.8.4" "User Contributed Perl Documentation"
.SH "NAME"
WordNet::QueryData \- direct perl interface to WordNet database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use WordNet::QueryData;
.Ve
.PP
.Vb 1
\&  my $wn = WordNet::QueryData\->new;
.Ve
.PP
.Vb 7
\&  print "Synset: ", join(", ", $wn\->querySense("cat#n#7", "syns")), "\en";
\&  print "Hyponyms: ", join(", ", $wn\->querySense("cat#n#1", "hypo")), "\en";
\&  print "Parts of Speech: ", join(", ", $wn\->querySense("run")), "\en";
\&  print "Senses: ", join(", ", $wn\->querySense("run#v")), "\en";
\&  print "Forms: ", join(", ", $wn\->validForms("lay down#v")), "\en";
\&  print "Noun count: ", scalar($wn\->listAllWords("noun")), "\en";
\&  print "Antonyms: ", join(", ", $wn\->queryWord("dark#n#1", "ants")), "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
WordNet::QueryData provides a direct interface to the WordNet database
files.  It requires the WordNet package
(http://www.cogsci.princeton.edu/~wn/).  It allows the user direct
access to the full WordNet semantic lexicon.  All parts of speech are
supported and access is generally very efficient because the index and
morphical exclusion tables are loaded at initialization.  This
initialization step is slow (appx. 10\-15 seconds), but queries are
very fast thereafter\-\-\-thousands of queries can be completed every
second.
.SH "USAGE"
.IX Header "USAGE"
.Sh "\s-1LOCATING\s0 \s-1THE\s0 \s-1WORDNET\s0 \s-1DATABASE\s0"
.IX Subsection "LOCATING THE WORDNET DATABASE"
To use QueryData, you must tell it where your WordNet database is.
There are two ways you can do this: 1) by setting the appropriate
environment variables, or 2) by passing the location to QueryData when
you invoke the \*(L"new\*(R" function.
.PP
QueryData knows about two environment variables, \s-1WNHOME\s0 and
\&\s-1WNSEARCHDIR\s0.  If \s-1WNSEARCHDIR\s0 is set, QueryData looks for WordNet data
files there.  Otherwise, QueryData looks for WordNet data files in
WNHOME/dict (WNHOME\edict on a \s-1PC\s0).  If \s-1WNHOME\s0 is not set, it defaults
to \*(L"/usr/local/WordNet\-2.1\*(R" on Unix and \*(L"C:\eProgram Files\eWordNet\e2.1\*(R"
on a \s-1PC\s0.  Normally, all you have to do is to set the \s-1WNHOME\s0 variable
to the location where you unpacked your WordNet distribution.  The
database files are normally unpacked to the \*(L"dict\*(R" subdirectory.
.PP
You can also pass the location of the database files directly to
QueryData.  To do this, pass the location to \*(L"new\*(R":
.PP
.Vb 1
\&  my $wn = new WordNet::QueryData\->new("/usr/local/wordnet/dict")
.Ve
.PP
When calling \*(L"new\*(R" in this fashion, you can give it a second verbosity
argument; a true value will have QueryData print debugging
information.
.Sh "\s-1QUERYING\s0 \s-1THE\s0 \s-1DATABASE\s0"
.IX Subsection "QUERYING THE DATABASE"
There are two primary query functions, 'querySense' and 'queryWord'.
querySense accesses semantic (sense to sense) relations; queryWord
accesses lexical (word to word) relations.  The majority of relations
are semantic.  Some relations, including \*(L"also see\*(R", antonym,
pertainym, \*(L"participle of verb\*(R", and derived forms are lexical.
See the following WordNet documentation for additional information:
.PP
.Vb 1
\&  http://wordnet.princeton.edu/man/wninput.5WN#sect3
.Ve
.PP
Both functions take as their first argument a query string that takes
one of three types:
.PP
.Vb 3
\&  (1) word (e.g. "dog")
\&  (2) word#pos (e.g. "house#n")
\&  (3) word#pos#sense (e.g. "ghostly#a#1")
.Ve
.PP
Types (1) or (2) passed to querySense or queryWord will return a list
of possible query strings at the next level of specificity.  When type
(3) is passed to querySense or queryWord, it requires a second
argument, a relation.  Relations generally only work with one function
or the other, though some relations can be either semantic or lexical;
hence they may work for both functions.  Below is a list of known
relations, grouped according to the function they're most likely to
work with:
.PP
.Vb 8
\&  queryWord
\&  \-\-\-\-\-\-\-\-\-
\&  also \- also see
\&  ants \- antonyms
\&  deri \- derived forms (nouns and verbs only)
\&  part \- participle of verb (adjectives only)
\&  pert \- pertainym (pertains to noun) (adjectives only)
\&  vgrp \- verb group (verbs only)
.Ve
.PP
.Vb 31
\&  querySense
\&  \-\-\-\-\-\-\-\-\-\-
\&  also \- also see
\&  glos \- word definition
\&  syns \- synset words
\&  hype \- hypernyms
\&  inst \- instance of
\&  hypes \- hypernyms and "instance of"
\&  hypo \- hyponyms
\&  hasi \- has instance
\&  hypos \- hyponums and "has instance"
\&  mmem \- member meronyms
\&  msub \- substance meronyms
\&  mprt \- part meronyms
\&  mero \- all meronyms
\&  hmem \- member holonyms
\&  hsub \- substance holonyms
\&  hprt \- part holonyms
\&  holo \- all holonyms
\&  attr \- attributes (?)
\&  sim  \- similar to (adjectives only)
\&  enta \- entailment (verbs only)
\&  caus \- cause (verbs only)
\&  domn \- domain \- all
\&  dmnc \- domain \- category
\&  dmnu \- domain \- usage
\&  dmnr \- domain \- region
\&  domt \- member of domain \- all (nouns only)
\&  dmtc \- member of domain \- category (nouns only)
\&  dmtu \- member of domain \- usage (nouns only)
\&  dmtr \- member of domain \- region (nouns only)
.Ve
.PP
When called in this manner, querySense and queryWord will return a
list of related words/senses.  Note that as of WordNet 2.1, many
hypernyms have become \*(L"instance of\*(R" and many hyponyms have become \*(L"has
instance.\*(R"
.PP
Note that querySense and queryWord use type (3) query strings in
different ways.  A type (3) string passed to querySense specifies a
synset.  A type (3) string passed to queryWord specifies a specific
sense of a specific word.
.Sh "\s-1OTHER\s0 \s-1FUNCTIONS\s0"
.IX Subsection "OTHER FUNCTIONS"
\&\*(L"validForms\*(R" accepts a type (1) or (2) query string.  It returns a
list of all alternate forms (alternate spellings, conjugations,
plural/singular forms, etc.).  The type (1) query returns alternates
for all parts of speech (noun, verb, adjective, adverb).  \s-1WARNING:\s0
Only the first argument returned by validForms is certain to be valid
(i.e. recognized by WordNet).  Remaining arguments may not be valid.
.PP
\&\*(L"listAllWords\*(R" accepts a part of speech and returns the full list of
words in the WordNet database for that part of speech.
.PP
\&\*(L"level\*(R" accepts a type (3) query string and returns a distance (not
necessarily the shortest or longest) to the root in the hypernym
directed acyclic graph.
.PP
\&\*(L"offset\*(R" accepts a type (3) query string and returns the binary offset of
that sense's location in the corresponding data file.
.PP
\&\*(L"tagSenseCnt\*(R" accepts a type (2) query string and returns the tagsense_cnt
value for that lemma: \*(L"number of senses of lemma that are ranked
according to their frequency of occurrence in semantic concordance
texts.\*(R"
.PP
\&\*(L"lexname\*(R" accepts a type (3) query string and returns the lexname of
the sense; see WordNet lexnames man page for more information.
.PP
\&\*(L"frequency\*(R" accepts a type (3) query string and returns the frequency
count of the sense from tagged text; see WordNet cntlist man page
for more information.
.PP
See test.pl for additional example usage.
.SH "NOTES"
.IX Header "NOTES"
Requires access to WordNet database files (data.noun/noun.dat,
index.noun/noun.idx, etc.)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000\-2005 Jason Rennie.  All rights reserved.
.PP
This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1)
.PP
http://wordnet.princeton.edu/
.PP
http://people.csail.mit.edu/~jrennie/WordNet/
